<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Processamento de Imagem</title>
    <style>
        canvas {
            border: 1px solid black;
            margin: 10px;
        }
        #container {
            display: flex;
            flex-wrap: wrap;
        }
    </style>
</head>
<body>
    <input type="file" id="fileInput" />
    <div id="container">
        <canvas id="canvasOriginal"></canvas>
        <canvas id="canvasBlurred"></canvas>
        <canvas id="canvasEdges"></canvas>
    </div>
    <script>
        const fileInput = document.getElementById('fileInput');
        const canvasOriginal = document.getElementById('canvasOriginal');
        const canvasBlurred = document.getElementById('canvasBlurred');
        const canvasEdges = document.getElementById('canvasEdges');
        const ctxOriginal = canvasOriginal.getContext('2d');
        const ctxBlurred = canvasBlurred.getContext('2d');
        const ctxEdges = canvasEdges.getContext('2d');

        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            const reader = new FileReader();

            reader.onload = function (e) {
                const img = new Image();
                img.onload = function () {
                    canvasOriginal.width = img.width;
                    canvasOriginal.height = img.height;
                    canvasBlurred.width = img.width;
                    canvasBlurred.height = img.height;
                    canvasEdges.width = img.width;
                    canvasEdges.height = img.height;

                    // Desenhar a imagem original
                    ctxOriginal.drawImage(img, 0, 0);

                    // Aplicar desfoque e desenhar
                    ctxBlurred.filter = 'blur(10px)';
                    ctxBlurred.drawImage(img, 0, 0);

                    // Detectar bordas e desenhar
                    detectEdges();
                };
                img.src = e.target.result;
            };

            reader.readAsDataURL(file);
        });

        function detectEdges() {
            const imageData = ctxOriginal.getImageData(0, 0, canvasOriginal.width, canvasOriginal.height);
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const sobelData = new Uint8ClampedArray(data.length);

            // Sobel operator kernels
            const Gx = [
                -1, 0, 1,
                -2, 0, 2,
                -1, 0, 1
            ];
            const Gy = [
                -1, -2, -1,
                 0,  0,  0,
                 1,  2,  1
            ];

            // Apply Sobel filter
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let pixelX = 0;
                    let pixelY = 0;

                    // Apply Sobel kernels
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const pixel = (y + ky) * width + (x + kx);
                            const r = data[pixel * 4];
                            const g = data[pixel * 4 + 1];
                            const b = data[pixel * 4 + 2];
                            const gray = (r + g + b) / 3;

                            pixelX += gray * Gx[(ky + 1) * 3 + (kx + 1)];
                            pixelY += gray * Gy[(ky + 1) * 3 + (kx + 1)];
                        }
                    }

                    // Calculate gradient magnitude
                    const magnitude = Math.sqrt(pixelX * pixelX + pixelY * pixelY) >>> 0;

                    // Set pixel data
                    const index = (y * width + x) * 4;
                    sobelData[index] = sobelData[index + 1] = sobelData[index + 2] = magnitude;
                    sobelData[index + 3] = 255; // Alpha
                }
            }

            ctxEdges.putImageData(new ImageData(sobelData, width, height), 0, 0);
        }
    </script>
</body>
</html>
